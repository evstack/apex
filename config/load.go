package config

import (
	"bytes"
	"errors"
	"fmt"
	"os"

	"github.com/evstack/apex/pkg/types"
	"gopkg.in/yaml.v3"
)

// Generate writes a default config file with comments to the given path.
// Returns an error if the file already exists.
func Generate(path string) error {
	_, err := os.Stat(path)
	if err == nil {
		return fmt.Errorf("config file %q already exists", path)
	}
	if !errors.Is(err, os.ErrNotExist) {
		return fmt.Errorf("checking config path: %w", err)
	}
	return os.WriteFile(path, []byte(defaultConfigYAML), 0o644)
}

// defaultConfigYAML is the template written by Generate.
// Keep values in sync with DefaultConfig() â€” Load() decodes YAML on top of
// DefaultConfig(), so divergence means `apex init` output won't match runtime defaults.
const defaultConfigYAML = `# Apex configuration
# Generated by: apex init

data_source:
  # Celestia node RPC endpoint
  celestia_node_url: "http://localhost:26658"

  # Auth token: set via APEX_AUTH_TOKEN env var (not read from this file).

  # Namespaces to index (hex-encoded, 29 bytes = 58 hex chars each).
  namespaces: []

storage:
  # Path to the SQLite database file
  db_path: "apex.db"

rpc:
  # Address for the JSON-RPC API server (HTTP/WebSocket)
  listen_addr: ":8080"
  # Address for the gRPC API server
  grpc_listen_addr: ":9090"

sync:
  # Height to start syncing from (0 = genesis)
  start_height: 0
  # Number of headers per backfill batch
  batch_size: 64
  # Number of concurrent fetch workers
  concurrency: 4

subscription:
  # Event buffer size per subscriber (for API subscriptions)
  buffer_size: 64

log:
  # Log level: trace, debug, info, warn, error, fatal, panic
  level: "info"
  # Log format: json or console
  format: "json"
`

var validLogLevels = map[string]bool{
	"trace": true, "debug": true, "info": true,
	"warn": true, "error": true, "fatal": true, "panic": true,
}

// Load reads and validates a YAML config file at the given path.
// Environment variable APEX_AUTH_TOKEN overrides data_source.auth_token.
func Load(path string) (*Config, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("reading config: %w", err)
	}

	cfg := DefaultConfig()

	dec := yaml.NewDecoder(bytes.NewReader(data))
	dec.KnownFields(true)
	if err := dec.Decode(&cfg); err != nil {
		return nil, fmt.Errorf("parsing config: %w", err)
	}

	// Env var override.
	if token := os.Getenv("APEX_AUTH_TOKEN"); token != "" {
		cfg.DataSource.AuthToken = token
	}

	if err := validate(&cfg); err != nil {
		return nil, fmt.Errorf("validating config: %w", err)
	}

	return &cfg, nil
}

func validate(cfg *Config) error {
	if cfg.DataSource.CelestiaNodeURL == "" {
		return fmt.Errorf("data_source.celestia_node_url is required")
	}
	if cfg.Storage.DBPath == "" {
		return fmt.Errorf("storage.db_path is required")
	}
	if cfg.RPC.GRPCListenAddr == "" {
		return fmt.Errorf("rpc.grpc_listen_addr is required")
	}
	if cfg.Sync.BatchSize <= 0 {
		return fmt.Errorf("sync.batch_size must be positive")
	}
	if cfg.Sync.Concurrency <= 0 {
		return fmt.Errorf("sync.concurrency must be positive")
	}
	if cfg.Subscription.BufferSize <= 0 {
		return fmt.Errorf("subscription.buffer_size must be positive")
	}
	if !validLogLevels[cfg.Log.Level] {
		return fmt.Errorf("log.level %q is invalid; must be one of trace/debug/info/warn/error/fatal/panic", cfg.Log.Level)
	}
	if cfg.Log.Format != "json" && cfg.Log.Format != "console" {
		return fmt.Errorf("log.format %q is invalid; must be json or console", cfg.Log.Format)
	}

	// Validate namespace hex strings.
	for _, ns := range cfg.DataSource.Namespaces {
		if _, err := types.NamespaceFromHex(ns); err != nil {
			return fmt.Errorf("invalid namespace %q: %w", ns, err)
		}
	}

	return nil
}
